import rospy
from turtlesim.msg import Pose
from geometry_msgs.msg import Twist, Point
import math

class Turtle:

    def __init__(self):

        rospy.init_node('talker', anonymous=True)
        self.goal = Point()
        self.pose = Pose()

        self.pose_sub = rospy.Subscriber('/turtle1/pose', Pose, self.callback)
        self.publisher = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)
        self.goal_sub = rospy.Subscriber('/turtle1/goal', Point, self.get_goal_pose)

    def get_goal_pose(self, data):

        self.goal.x = data.x
        self.goal.y = data.y
        self.goal.z = data.z

    def callback(self, data):

        self.pose = data
        rospy.loginfo("Current position of the turtle: [ x: %f, y: %f ]"%(data.x, data.y))

    def get_euclidean_distance(self, pose, goal):
        return math.sqrt((self.goal.x - self.pose.x)**2 + (self.goal.y - self.pose.y)**2)

    def move(self):
        rospy.loginfo("CHECK [ x: %f, y: %f ]"%(self.goal.x, self.goal.y))
        
        self.rate = rospy.Rate(10)

        i = 0.1
        while self.get_euclidean_distance(self.pose, self.goal) > 0.01:
            rospy.loginfo("I AM HERE IN WHILE")
            
            move = Twist()
            move.linear.x = i * self.get_euclidean_distance(self.pose, self.goal)
            move.linear.y = i * self.get_euclidean_distance(self.pose, self.goal)
            move.angular.z = math.tan(i)

            self.publisher.publish(move)
            
            self.rate.sleep()
            i += 0.1

            rospy.spin()
        
if __name__ == '__main__':
    try:
        tur = Turtle()
        tur.move()
    except rospy.ROSInterruptException:
        pass

