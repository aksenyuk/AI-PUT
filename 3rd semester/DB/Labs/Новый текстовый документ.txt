#######TASKS 1

select * from zespoly;

select * from prownicy;

select nazwisko, placa_pod * 12 from pracownicy;

select etat, placa_pod + coalesce(placa_dod, 0) as miesieczne_zarobki from pracownicy;

select id_zesp, nazwa, adres from zespoly order by nazwa;

select unique nazwa from etaty;

select * from etaty where nazwa = 'ASYSTENT';

select id_prac, nazwisko, etat, placa_pod, id_zesp from pracownicy where id_zesp in (30, 40) order by placa_pod desc;

select nazwisko, id_zesp, placa_pod from pracownicy where placa_pod between 300 and 800;

select nazwisko, etat, id_zesp from pracownicy where nazwisko like '%SKI';

select id_prac, id_szefa, nazwisko, placa_pod from pracownicy where id_szefa is not null and placa_pod > 1000;

select nazwisko, id_zesp from pracownicy where (nazwisko like 'M%' or nazwisko like '%SKI') and id_zesp = 20;

select nazwisko, etat, placa_pod/20/8 as stawka from pracownicy where etat not in ('ADIUNKT', 'STAZYSTA', 'ASYSTENT') and placa_pod not between 400 and 800 order by stawka;

select nazwisko, etat, placa_pod, placa_dod from pracownicy where placa_pod + coalesce(placa_dod, 0) > 1000 order by etat, nazwisko;

select nazwisko || ' pracuje od ' || zatrudniony || ' i zarabia ' || placa_pod as profesorowie from pracownicy where etat = 'PROFESOR' order by placa_pod desc;

#######TASK 2

select nazwisko, substr(etat, 1, 2) || id_prac as kod from pracownicy;

select nazwisko, translate(nazwisko, 'KLM', 'XXX') as wojna from pracownicy;

select nazwisko from pracownicy where instr(substr(nazwisko, 1, length(nazwisko) / 2), 'L', 1, 1) > 0;

select nazwisko, round(placa_pod * 1.15) as podwyzka from pracownicy;

select nazwisko, to_char(zatrudniony,'YY/DD/MM') as zatrudni, extract(year from (date '2000-01-01' - zatrudniony) year to month) as staz_w_2000 from pracownicy;

select nazwisko, to_char(zatrudniony,'MONTH, DD YYYY') as data_zatrudnienia from pracownicy where id_zesp = 20;

select to_char(current_date, 'DAY') as dzien from dual;

select nazwa, adres,
	case (substr(adres, 1, instr(adres, ' ') - 1))
		when 'PIOTROWO'   then 'NOWE MIASTO'
		when 'WLODKOWICA' then 'GRUNWALD'
		else 'STARE MIASTO'
	end as dzielnica
from zespoly;

select nazwisko, placa_pod,
	case
		when placa_pod < 480 then 'less'
		when placa_pod = 480 then 'equal'
		else 'more'
	end as prog
from pracownicy
order by placa_pod desc;


#######TASK 3

-- etaty, pracownicy, zespoly
select min(placa_pod), max(placa_pod), max(placa_pod) - min(placa_pod) from pracownicy;

select etat, avg(placa_pod) as srednia from pracownicy group by etat order by srednia desc;

select count(*) as profesorowie from pracownicy group by etat having etat = 'PROFESOR';

select id_zesp, sum(placa_pod) + sum(placa_dod) as sumaryczne from pracownicy group by id_zesp order by id_zesp;

select max(sum(placa_pod) + sum(placa_dod)) as max_sum_placa from pracownicy group by id_zesp;

select id_szefa, min(placa_pod) as minimalna from pracownicy group by id_szefa order by id_szefa;

select id_zesp, count(*) as ilu_pracuje from pracownicy group by id_zesp order by ilu_pracuje desc;

select id_zesp, count(*) as ilu_pracuje from pracownicy group by id_zesp having count(*) > 3 order by ilu_pracuje desc;

select id_prac, count(*) as duplikaty from pracownicy group by id_prac having count(*) > 1;

select etat, avg(placa_pod) as srednia, count(*) as liczba from pracownicy where extract(year from zatrudniony) <= 1990 group by etat order by etat;

select id_zesp, etat, avg(placa_pod + placa_dod) as srednia, max(placa_pod + placa_dod)
from pracownicy
where etat in ('PROFESOR', 'ASYSTENT')
group by id_zesp, etat
order by id_zesp, etat;

select extract(year from zatrudniony) as rok, count(*) as ilu_pracownikow
from pracownicy
group by extract(year from zatrudniony)
order by rok;

select length(nazwisko) as ile_liter, count(*) as w_ilu
from pracownicy
group by length(nazwisko)
order by ile_liter;

select
	count(case when instr(nazwisko, 'A', 1, 1) > 0 then 1 else null end) as ile_a,
	count(case when instr(nazwisko, 'E', 1, 1) > 0 then 1 else null end) as ile_b
from pracownicy;

select
	id_zesp, sum(placa_pod) as suma_plac,
	listagg(nazwisko || ':' || placa_pod, ',') 
	within group (order by nazwisko) as pracownicy
from pracownicy
group by id_zesp
order by id_zesp;

#########TASK 4

select p.nazwisko, p.etat, p.id_zesp, z.nazwa
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
order by p.nazwisko;<Paste>

select p.nazwisko, p.etat, p.id_zesp, z.nazwa
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
where z.adres = 'PIOTROWO 3A'
order by p.nazwisko;

select p.nazwisko, p.etat, p.placa_pod, e.placa_min, e.placa_max
from pracownicy p inner join etaty e on p.etat = e.nazwa
order by p.nazwisko;

select p.nazwisko, p.etat, p.placa_pod, e.placa_min, e.placa_max,
	case when e.placa_min <= p.placa_pod and p.placa_pod <= e.placa_max then 'OK' else 'ERR' end as czy_pensja_ok
from pracownicy p inner join etaty e on p.etat = e.nazwa
order by p.nazwisko;

select p.nazwisko, p.etat, p.placa_pod, e.placa_min, e.placa_max
from pracownicy p inner join etaty e on p.etat = e.nazwa
where p.placa_pod < e.placa_min or p.placa_pod > e.placa_max
order by p.nazwisko;

select p.nazwisko, p.etat, e.nazwa as kat_plac, p.placa_pod, e.placa_min, e.placa_max
from pracownicy p inner join etaty e on e.placa_min <= p.placa_pod and p.placa_pod <= e.placa_max
order by p.nazwisko, kat_plac;

select p.nazwisko, p.etat, e.nazwa as kat_plac, p.placa_pod, e.placa_min, e.placa_max
from pracownicy p inner join etaty e on e.placa_min <= p.placa_pod and p.placa_pod <= e.placa_max
where e.nazwa = 'SEKRETARKA'
order by p.nazwisko, kat_plac;

select p.nazwisko, p.id_prac, s.nazwisko as szef, s.id_prac as id_szefa
from pracownicy p inner join pracownicy s on p.id_szefa = s.id_prac
order by p.nazwisko;

select
	p.nazwisko as pracownik, p.zatrudniony as p_zat, s.nazwisko as szef, s.zatrudniony as s_zat,
	extract(year from p.zatrudniony) - extract(year from s.zatrudniony) as lata
from pracownicy p inner join pracownicy s on p.id_szefa = s.id_prac
where extract(year from p.zatrudniony) - extract(year from s.zatrudniony) < 10
order by lata, p.nazwisko;

select z.nazwa, count(*) as liczba_prac, avg(p.placa_pod) as srednia_placa
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
group by z.nazwa
order by z.nazwa;

select
	z.nazwa, 
	case
		when count(*) >= 7 then 'big'
		when count(*) >= 3 then 'medium'
		else 'small'
	end as etykieta
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
group by z.nazwa
having count(*) > 0
order by z.nazwa;


#########TASK 5



########TASK 6

-- pracownicy: id_prac, nazwisko, etat, id_szefa, zatrudniony, placa_pod/dod, id_zesp

select nazwisko, etat, id_zesp
from pracownicy
where id_zesp = (
	select id_zesp
	from pracownicy
	where nazwisko = 'BRZEZINSKI'
)
order by nazwisko;

select p.nazwisko, p.etat, z.nazwa
from pracownicy p join zespoly z on p.id_zesp = z.id_zesp
where p.id_zesp = (
	select id_zesp
	from pracownicy
	where nazwisko = 'BRZEZINSKI'
)
order by p.nazwisko;

select nazwisko, etat, zatrudniony
from pracownicy
where 
etat = 'PROFESOR' and
zatrudniony = (
	select min(zatrudniony)
	from pracownicy
  	where etat = 'PROFESOR'
);

select nazwisko, zatrudniony, id_zesp
from pracownicy
where zatrudniony in (
	select max(zatrudniony)
	from pracownicy
	group by id_zesp
)
order by zatrudniony;

select nazwa from zespoly
where id_zesp is not null and id_zesp not in (
	select distinct id_zesp
	from pracownicy
);

select nazwisko
from pracownicy
where etat = 'PROFESOR' and id_prac not in (
	select id_szefa
	from pracownicy
	where etat = 'STAZYSTA'
)

select p.id_zesp, sum(p.placa_pod) as suma_plac
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
group by p.id_zesp
having sum(p.placa_pod) = (
	select max(sum(p.placa_pod))
	from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
	group by p.id_zesp
)
order by suma_plac desc;

select z.nazwa, sum(p.placa_pod) as suma_plac
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
group by z.id_zesp, z.nazwa
having sum(p.placa_pod) = (
	select max(sum(p.placa_pod))
	from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
	group by p.id_zesp
)
order by suma_plac desc;

select z.nazwa, count(*) as ilu_pracownikow
from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
group by z.id_zesp, z.nazwa
having count(*) > (
	select count(*)
	from pracownicy p inner join zespoly z on p.id_zesp = z.id_zesp
	group by z.id_zesp, z.nazwa
	having z.nazwa = 'ADMINISTRACJA'
)
order by z.nazwa;

select etat
from pracownicy
group by etat
having count(*) = (
	select max(count(*))
	from pracownicy
	group by etat
);

select etat, listagg(nazwisko, ',') within group (order by nazwisko) as pracownicy
from pracownicy
group by etat
having count(*) = (
	select max(count(*))
	from pracownicy
	group by etat
);

select p.nazwisko as pracownik, s.nazwisko as szef
from pracownicy p inner join pracownicy s on p.id_szefa = s.id_prac
where s.placa_pod - p.placa_pod = (
	select min(abs(s.placa_pod - p.placa_pod))
	from pracownicy p inner join pracownicy s on p.id_szefa = s.id_prac
);


#######TASK 7


######TASK 8

-- ex 1
insert into pracownicy (id_prac, nazwisko, etat, id_szefa, zatrudniony, placa_pod, placa_dod, id_zesp) values
    (231, 'Foo', 'ASYSTENT', 100, date '2018-01-01', 600, null, 10);
insert into pracownicy (id_prac, nazwisko, etat, id_szefa, zatrudniony, placa_pod, placa_dod, id_zesp) values
    (232, 'Bar', 'ASYSTENT', 100, date '2018-01-01', 600, 120, 10);
insert into pracownicy (id_prac, nazwisko, etat, id_szefa, zatrudniony, placa_pod, placa_dod, id_zesp) values
    (233, 'Baz', 'ASYSTENT', 100, date '2018-01-01', 208, 130, 10);
    
-- ex 2
update pracownicy p
set (p.placa_pod, p.placa_dod) = (
    select 1.1 * placa_pod, coalesce(1.2 * placa_dod, 100)
    from pracownicy
    where id_prac = p.id_prac
)
where p.zatrudniony = date '2018-01-01';

-- ex 3
insert into zespoly (id_zesp, nazwa, adres) values (60, 'BAZY DANYCH', 'PIOTROWO 2');

-- ex 4
update pracownicy p
set (p.id_zesp) = (select id_zesp from zespoly where nazwa = 'BAZY DANYCH')
where p.zatrudniony = date '2018-01-01';

-- ex 5
update pracownicy p
set (p.id_szefa) = (select id_prac from pracownicy where nazwisko = 'MORZY')
where p.id_zesp = (select id_zesp from zespoly where nazwa = 'BAZY DANYCH');

-- ex 6
delete from zespoly where nazwa = 'BAZY DANYCH';

-- ex 7
delete from pracownicy where id_zesp = (select id_zesp from zespoly where nazwa = 'BAZY DANYCH');
delete from zespoly where nazwa = 'BAZY DANYCH';

-- ex 8
select id_zesp, 0.1 * avg(placa_pod)
from pracownicy
group by id_zesp;

-- ex 9
update pracownicy p
set (p.placa_pod) = (
    select p.placa_pod + 0.1 * avg(placa_pod)
    from pracownicy
    group by id_zesp
    having id_zesp = p.id_zesp
);

-- ex 10
select *
from pracownicy
order by placa_pod asc
fetch first 1 rows with ties;

-- ex 11
update pracownicy p
set (p.placa_pod) = (
    select avg(placa_pod) from pracownicy
)
where p.id_prac in (
    select id_prac
    from pracownicy
    order by placa_pod asc
    fetch first 1 rows with ties
);

-- ex 12
select round(avg(placa_pod), 2)
from pracownicy
where id_szefa = (select id_szefa from pracownicy where nazwisko = 'MORZY');

select * from pracownicy order by nazwisko asc;
select * from zespoly;
rollback;

########TASK 9

-- SBD Laboratorium 9
-- Język definiowania danych DDL, część 1

-- ex 1
create table projekty (
    id_projektu number(4) generated always as identity,
    opis_projektu varchar(20),
    data_rozpoczecia date default current_date,
    data_zakonczenia date,
    fundusz number(7, 2)
);

-- ex 2
insert into projekty (opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz) values
    ('Indeksy bitmapowe', date '1999-04-02', date '2001-08-31', 25000);
insert into projekty (opis_projektu, data_zakonczenia, fundusz) values
    ('Sieci kręgosłupowe', null, 19000);

-- ex 3
select id_projektu, opis_projektu from projekty;

-- ex 4
-- nie można ustawić ręcznie indeksu, jeśli oznaczyliśmy jako 'generate always'
insert into projekty (opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz) values
    ('Indeksy drzewiaste', date '2013-12-24', date '2014-01-01', 1200);

-- ex 5
-- nie można nadpisać ręcznie indeksu, patrz ex4
update projekty p set p.id_projektu = 10
where p.opis_projektu = 'Indeksy drzewiaste';

-- ex 6
create table projekty_kopia as (select * from projekty);
select * from projekty_kopia;

-- ex 7
-- powiedzie się, ponieważ kopia tabeli nie zachowała atrybutu 'generate always'
insert into projekty_kopia (id_projektu, opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz) values
    (10, 'Sieci lokalne', current_date, current_date + interval '1' year , 1200);
select * from projekty_kopia;
describe projekty_kopia;

-- ex 8
-- usunięcie nie modyfikuje kopii, co jest oczywiste...
delete from projekty where opis_projektu = 'Indeksy drzewiaste';
select * from projekty;
select * from projekty_kopia;

-- ex 9
select table_name from tabs order by table_name;

-- rollback
drop table projekty;
drop table projekty_kopia;

########TASK 10

-- SBD Laboratorium 10
-- Język definiowania danych DDL, część 2

-- ex 1
alter table projekty
add (
    constraint pk_projekty primary key(id_projektu),
    constraint uk_projekty unique(opis_projektu),
    check(data_zakonczenia > data_rozpoczecia),
    check(fundusz >= 0)
)
modify (
    opis_projektu not null
);

select k.constraint_name, k.constraint_type, k.search_condition, c.column_name
from user_constraints k
inner join user_cons_columns c on k.constraint_name = c.constraint_name
where k.table_name = 'PROJEKTY'
order by k.constraint_name;

-- ex 2
insert into projekty (opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz) values
    ('Indeksy bitmapowe', date '2015-04-12', date '2016-08-30', 40000);

-- ex 3
create table przydzialy (
    id_projektu number(4) constraint fk_przydzialy_01 references projekty(id_projektu) not null,
    nr_pracownika number(6) constraint fk_przydzialy_02 references pracownicy(id_prac) not null,
    od date default current_date,
    do date, constraint chk_przydzialy_daty check(do > od), -- ważny przecinek: bo odwołanie do innej kolumny
    stawka number(7, 2) constraint chk_przydzialy_stawka check(stawka > 0),
    rola varchar(20) constraint chk_przydzialy_rola check(rola in ('KIERUJĄCY', 'ANALITYK', 'PROGRAMISTA'))
);

-- ex 4
insert into przydzialy (id_projektu, nr_pracownika, od, do, stawka, rola) values
    ((select id_projektu from projekty where opis_projektu = 'Indeksy bitmapowe'),
    170, date '1999-04-10', date '1999-05-10', 1000, 'KIERUJĄCY');
insert into przydzialy (id_projektu, nr_pracownika, od, stawka, rola) values
    ((select id_projektu from projekty where opis_projektu = 'Indeksy bitmapowe'),
    140, date '2000-12-01', 1500, 'ANALITYK');
insert into przydzialy (id_projektu, nr_pracownika, od, stawka, rola) values
    ((select id_projektu from projekty where opis_projektu = 'Sieci kręgosłupowe'),
    140, date '2015-09-14', 2500, 'KIERUJĄCY');
select * from przydzialy;

-- ex 5
-- nie można dodać kolumny not null, jeżeli są już jakieś rekordy
alter table przydzialy add godziny number(4) check(godziny <= 9999) not null;

-- ex 6
alter table przydzialy add godziny number(4);
create sequence godzinki start with 10 increment by 10;
update przydzialy set godziny = godzinki.nextval;
drop sequence godzinki;
alter table przydzialy add (check(godziny <= 9999)) modify (godziny not null);
select * from przydzialy;

-- ex 7
alter table projekty disable constraint uk_projekty;
select constraint_name, status
from user_constraints
where constraint_name = 'UK_PROJEKTY';

-- ex 8
insert into projekty (opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz)
    values ('Indeksy bitmapowe', date '2015-04-12', date '2016-09-30', 40000);
select * from projekty;

-- ex 9
alter table projekty enable constraint uk_projekty;

-- ex 10
update projekty set opis_projektu = 'Inne indeksy' where id_projektu = 4;
alter table projekty enable constraint uk_projekty;

-- ex 11
alter table projekty modify opis_projektu varchar(10);

-- ex 12
-- sieci kręgosłupowe są używane w tabeli przydziały
delete from projekty where opis_projektu = 'Sieci kręgosłupowe';

-- ex 13
alter table przydzialy drop constraint fk_przydzialy_01;
alter table przydzialy add constraint fk_przydzialy_01 foreign key(id_projektu) references projekty(id_projektu) on delete cascade;
delete from projekty where opis_projektu = 'Sieci kręgosłupowe';
select * from projekty;
select * from przydzialy;

-- ex 14
drop table projekty cascade constraints;

select constraint_name, constraint_type as C, search_condition
from user_constraints
where table_name = 'PRZYDZIALY'
order by constraint_name;

-- ex 15
drop table przydzialy;
drop table projekty_kopia;
select table_name from user_tables;


####### EXTRA TASK

-- SBD Laboratorium 10
-- Język definiowania danych DDL, część 2

-- ex 1
alter table projekty
add (
    constraint pk_projekty primary key(id_projektu),
    constraint uk_projekty unique(opis_projektu),
    check(data_zakonczenia > data_rozpoczecia),
    check(fundusz >= 0)
)
modify (
    opis_projektu not null
);

select k.constraint_name, k.constraint_type, k.search_condition, c.column_name
from user_constraints k
inner join user_cons_columns c on k.constraint_name = c.constraint_name
where k.table_name = 'PROJEKTY'
order by k.constraint_name;

-- ex 2
insert into projekty (opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz) values
    ('Indeksy bitmapowe', date '2015-04-12', date '2016-08-30', 40000);

-- ex 3
create table przydzialy (
    id_projektu number(4) constraint fk_przydzialy_01 references projekty(id_projektu) not null,
    nr_pracownika number(6) constraint fk_przydzialy_02 references pracownicy(id_prac) not null,
    od date default current_date,
    do date, constraint chk_przydzialy_daty check(do > od), -- ważny przecinek: bo odwołanie do innej kolumny
    stawka number(7, 2) constraint chk_przydzialy_stawka check(stawka > 0),
    rola varchar(20) constraint chk_przydzialy_rola check(rola in ('KIERUJĄCY', 'ANALITYK', 'PROGRAMISTA'))
);

-- ex 4
insert into przydzialy (id_projektu, nr_pracownika, od, do, stawka, rola) values
    ((select id_projektu from projekty where opis_projektu = 'Indeksy bitmapowe'),
    170, date '1999-04-10', date '1999-05-10', 1000, 'KIERUJĄCY');
insert into przydzialy (id_projektu, nr_pracownika, od, stawka, rola) values
    ((select id_projektu from projekty where opis_projektu = 'Indeksy bitmapowe'),
    140, date '2000-12-01', 1500, 'ANALITYK');
insert into przydzialy (id_projektu, nr_pracownika, od, stawka, rola) values
    ((select id_projektu from projekty where opis_projektu = 'Sieci kręgosłupowe'),
    140, date '2015-09-14', 2500, 'KIERUJĄCY');
select * from przydzialy;

-- ex 5
-- nie można dodać kolumny not null, jeżeli są już jakieś rekordy
alter table przydzialy add godziny number(4) check(godziny <= 9999) not null;

-- ex 6
alter table przydzialy add godziny number(4);
create sequence godzinki start with 10 increment by 10;
update przydzialy set godziny = godzinki.nextval;
drop sequence godzinki;
alter table przydzialy add (check(godziny <= 9999)) modify (godziny not null);
select * from przydzialy;

-- ex 7
alter table projekty disable constraint uk_projekty;
select constraint_name, status
from user_constraints
where constraint_name = 'UK_PROJEKTY';

-- ex 8
insert into projekty (opis_projektu, data_rozpoczecia, data_zakonczenia, fundusz)
    values ('Indeksy bitmapowe', date '2015-04-12', date '2016-09-30', 40000);
select * from projekty;

-- ex 9
alter table projekty enable constraint uk_projekty;

-- ex 10
update projekty set opis_projektu = 'Inne indeksy' where id_projektu = 4;
alter table projekty enable constraint uk_projekty;

-- ex 11
alter table projekty modify opis_projektu varchar(10);

-- ex 12
-- sieci kręgosłupowe są używane w tabeli przydziały
delete from projekty where opis_projektu = 'Sieci kręgosłupowe';

-- ex 13
alter table przydzialy drop constraint fk_przydzialy_01;
alter table przydzialy add constraint fk_przydzialy_01 foreign key(id_projektu) references projekty(id_projektu) on delete cascade;
delete from projekty where opis_projektu = 'Sieci kręgosłupowe';
select * from projekty;
select * from przydzialy;

-- ex 14
drop table projekty cascade constraints;

select constraint_name, constraint_type as C, search_condition
from user_constraints
where table_name = 'PRZYDZIALY'
order by constraint_name;

-- ex 15
drop table przydzialy;
drop table projekty_kopia;
select table_name from user_tables;